import{_ as a,i as t,h as e,O as o}from"./chunks/framework.9399b50c.js";const r="/notes/algorithm/classic/arr.png",i="/notes/algorithm/classic/stack.png",s="/notes/algorithm/classic/queue.png",p="/notes/algorithm/classic/hash.png",l="/notes/algorithm/classic/link.png",n="/notes/algorithm/classic/tree.png",x=JSON.parse('{"title":"算法中常见的数据结构","description":"","frontmatter":{"author":"liaoyi"},"headers":[],"relativePath":"algorithm/guide/index.md","lastUpdated":1696236510000}'),c={name:"algorithm/guide/index.md"},h=o('<h1 id="算法中常见的数据结构" tabindex="-1">算法中常见的数据结构 <a class="header-anchor" href="#算法中常见的数据结构" aria-label="Permalink to &quot;算法中常见的数据结构&quot;">​</a></h1><p>选用合适的数据结构是算法设计的重要一环，常见的数据结构有：数组、栈、队列、哈希表、链表、树、图、堆等。</p><p>这些数据结构都有各自的特点，甚至在某些场景下，它们之间还可以相互转换。比如，数组既可以用来顺序存储，也可以用来实现栈、队列和散列表。</p><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><p>数组它是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。</p><p>数组的优点是支持随机访问，根据下标随机访问的时间复杂度是 O(1)。但是，数组也有缺点，比如，如果要在数组的头部或者中间插入一个元素，为了保证内存空间的连续性，就需要做大量的数据搬移工作，时间复杂度是 O(n)。</p><p><img src="'+r+'" alt=""></p><h2 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h2><p>栈是一种先进后出（First In Last Out）的数据结构，它只支持在一端插入和删除数据。</p><p>栈的应用场景有函数调用栈、括号匹配、表达式求值等。</p><p><img src="'+i+'" alt=""></p><h2 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h2><p>队列是一种先进先出（First In First Out）的数据结构，它只支持在队尾插入数据，在队头删除数据。</p><p>队列的应用场景有广度优先搜索、缓存淘汰策略等。</p><p><img src="'+s+'" alt=""></p><blockquote><p>另外还有一种队列叫做双端队列（Deque），它支持在队头和队尾插入和删除数据。</p></blockquote><h2 id="哈希表-散列表" tabindex="-1">哈希表（散列表） <a class="header-anchor" href="#哈希表-散列表" aria-label="Permalink to &quot;哈希表（散列表）&quot;">​</a></h2><p>散列表是根据关键码值（Key Value）而直接进行访问的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</p><p>散列表的应用场景有缓存、数据库索引等。优点是查找速度快，缺点是占用内存大，而且容易出现散列冲突。</p><blockquote><p>散列冲突: 两个不同的关键码值经过散列函数计算得到的散列地址相同，这种现象称为散列冲突。</p></blockquote><p><img src="'+p+'" alt=""></p><h2 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h2><p>链表是一种非连续的线性表数据结构，它通过指针将一组零散的内存块串联起来使用。</p><p>链表的优点是支持动态扩容，不需要像数组那样预先分配一块连续的内存空间。但是，链表也有缺点，比如，如果要随机访问链表中的某个元素，就需要从头开始遍历，时间复杂度是 O(n)。</p><p><img src="'+l+'" alt=""></p><h2 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h2><p>树是一种非线性的数据结构，它是由 n(n&gt;=1) 个有限节点组成一个具有层次关系的集合。</p><p>树的节点包含两个基本部分：数据和指向子节点的指针。树的节点可以分为内部节点和外部节点。根节点是树的第一个节点，没有父节点的节点称为根节点。每个节点最多只能有一个父节点，但是可以有多个子节点。如果一个节点没有子节点，那么它就是叶子节点。</p><p>树的应用场景有二叉查找树、堆、Trie 树等。</p><p><img src="'+n+'" alt=""></p><h2 id="图" tabindex="-1">图 <a class="header-anchor" href="#图" aria-label="Permalink to &quot;图&quot;">​</a></h2><p>图是一种非线性的数据结构，它由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p><p>图的应用场景有最短路径算法、拓扑排序、求解关键路径等。</p><h2 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h2><p>堆是一种特殊的树形数据结构，它满足下列性质：</p><ul><li>是一棵完全二叉树</li><li>树中的任意节点的值总是不大于（或不小于）其子节点的值</li></ul><p>堆的应用场景有求 Top K 问题、求中位数等。</p>',37),d=[h];function _(u,m,g,q,b,k){return e(),t("div",null,d)}const P=a(c,[["render",_]]);export{x as __pageData,P as default};
