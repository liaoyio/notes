import{_ as a,i as e,h as l,O as t}from"./chunks/framework.9399b50c.js";const o="/notes/assets/xr-url.0d66612d.png",r="/notes/assets/xr.88c2d11e.png",i="/notes/assets/xr-2.af6fdbd7.png",s="/notes/assets/xr-3.74d2f9b1.png",n="/notes/assets/xr-4.2d5e6169.png",d="/notes/assets/xr-all.10744484.png",T=JSON.parse('{"title":"「导航渲染流程」你真的知道从输入 URL 到页面展示发生了什么吗？（内附思维导图）","description":"","frontmatter":{"author":"HearLing"},"headers":[],"relativePath":"basic/os_net_browser/08_enter_url.md","lastUpdated":1696236510000}'),c={name:"basic/os_net_browser/08_enter_url.md"},p=t('<h1 id="「导航渲染流程」你真的知道从输入-url-到页面展示发生了什么吗-内附思维导图" tabindex="-1">「导航渲染流程」你真的知道从输入 URL 到页面展示发生了什么吗？（内附思维导图） <a class="header-anchor" href="#「导航渲染流程」你真的知道从输入-url-到页面展示发生了什么吗-内附思维导图" aria-label="Permalink to &quot;「导航渲染流程」你真的知道从输入 URL 到页面展示发生了什么吗？（内附思维导图）&quot;">​</a></h1><h2 id="导航渲染流程" tabindex="-1">导航渲染流程 <a class="header-anchor" href="#导航渲染流程" aria-label="Permalink to &quot;导航渲染流程&quot;">​</a></h2><p><img src="'+o+`" alt=""></p><p>从输入到页面渲染这个过程其实可以说得非常复杂，包括了两大步骤，一个是导航流程另一个是渲染流程；</p><hr><h2 id="导航流程" tabindex="-1">导航流程 <a class="header-anchor" href="#导航流程" aria-label="Permalink to &quot;导航流程&quot;">​</a></h2><h2 id="_1-用户输入-url" tabindex="-1">1.用户输入 URL <a class="header-anchor" href="#_1-用户输入-url" aria-label="Permalink to &quot;1.用户输入 URL&quot;">​</a></h2><p>不考虑用户输入搜索关键字的情况， 如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL</p><h2 id="_2-loading-状态" tabindex="-1">2.loading 状态 <a class="header-anchor" href="#_2-loading-状态" aria-label="Permalink to &quot;2.loading 状态&quot;">​</a></h2><p>用户输入完内容，按下回车键，浏览器导航栏显示<code>loading</code>状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获取到。</p><h2 id="_3-浏览器请求" tabindex="-1">3.浏览器请求 <a class="header-anchor" href="#_3-浏览器请求" aria-label="Permalink to &quot;3.浏览器请求&quot;">​</a></h2><p>浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将 URL 请求发送给网络进程</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">GET /index.html HTTP1.1</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_4-网络进程处理" tabindex="-1">4.网络进程处理 <a class="header-anchor" href="#_4-网络进程处理" aria-label="Permalink to &quot;4.网络进程处理&quot;">​</a></h2><p>网络进程接收到<code>url</code>请求后检查本地缓存是否缓存了该请求资源：</p><ul><li>如果有缓存文件 <ul><li>拦截请求，直接 200 返回</li></ul></li><li>无缓存文件 <ul><li>进入网络请求过程</li></ul></li></ul><p>请求 DNS（返回对应 IP 端口）</p><ul><li>缓存过当前域名信息 <ul><li>直接返回缓存信息</li></ul></li><li>未缓存 <ul><li>发起请求获取根据域名解析出来的 IP 和端口号</li></ul></li></ul><h2 id="_5-tcp-三次握手建立连接" tabindex="-1">5.TCP 三次握手建立连接 <a class="header-anchor" href="#_5-tcp-三次握手建立连接" aria-label="Permalink to &quot;5.TCP 三次握手建立连接&quot;">​</a></h2><p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6 个，会直接建立 TCP 连接。</p><p>TCP 三次握手建立连接，http 请求加上 TCP 头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输 http 请求加上 TCP 头部向下传输</p><div class="tip custom-block"><p class="custom-block-title">参考链接 <a href="https://blog.csdn.net/qq_41147507/article/details/109593886" target="_blank" rel="noreferrer"><code>三次握手建立连接详细过程</code></a></p></div><h2 id="_6-数据传输过程" tabindex="-1">6.数据传输过程 <a class="header-anchor" href="#_6-数据传输过程" aria-label="Permalink to &quot;6.数据传输过程&quot;">​</a></h2><p><strong>网络层、传输层</strong> 在数据包上加上 IP 头部，继续向下传输到底层，底层通过物理网络传输给目的服务器主机</p><ul><li>网络层在数据包上加上 IP 头部——包括源 IP 地址和目的 IP 地址，继续向下传输到底层</li></ul><p><strong>目的服务器主机</strong></p><ul><li>网络层，解析出 IP 头部，识别出数据部分</li><li>传输层获取到数据包，解析出 TCP 头部，识别端口</li></ul><p><strong>应用层 HTTP 解析请求头和请求体</strong> 应用层 HTTP 解析请求头和请求体，如果需要重定向，HTTP 直接返回 HTTP 响应数据的状态<code>code301</code>或者<code>302</code>，同时在请求头的<code>Location</code>字段中附上重定向地址，浏览器会根据<code>code</code>和<code>Location</code>进行重定向操作；</p><p>如果不是重定向，首先服务器会根据 请求头中的 If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；</p><p>否则，返回新数据，200 的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：Cache-Control:Max-age=2000</p><ul><li>重定向 HTTP 直接返回 HTTP 响应数据的状态<code>code301</code>或者<code>302</code> 同时在请求头的 Location 字段中附上重定向地址</li><li>不是重定向 <code>If-None-Match</code>,没有更新，就返回<code>304</code>状态码;否则，返回新数据，<code>200</code>的状态码 <code>Cache-Control</code>,想要浏览器缓存数据</li></ul><p><strong>响应数据</strong>又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到<strong>网络进程</strong></p><h2 id="_7-传输完成-tcp-四次挥手" tabindex="-1">7.传输完成，TCP 四次挥手 <a class="header-anchor" href="#_7-传输完成-tcp-四次挥手" aria-label="Permalink to &quot;7.传输完成，TCP 四次挥手&quot;">​</a></h2><h2 id="_8-网络进程-数据包解析" tabindex="-1">8.网络进程（数据包解析） <a class="header-anchor" href="#_8-网络进程-数据包解析" aria-label="Permalink to &quot;8.网络进程（数据包解析）&quot;">​</a></h2><p><strong>Content-type</strong></p><p>网络进程将获取到的数据包进行解析，根据响应头中的<code>Content-type</code>来判断响应数据的类型</p><ul><li><p>如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行</p></li><li><p>如果是 text/html 类型，就通知浏览器进程获取到文档准备渲染</p></li></ul><h2 id="_9-渲染进程-渲染进程的主进程" tabindex="-1">9.渲染进程（渲染进程的主进程） <a class="header-anchor" href="#_9-渲染进程-渲染进程的主进程" aria-label="Permalink to &quot;9.渲染进程（渲染进程的主进程）&quot;">​</a></h2><p>浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程</p><ul><li>网络进程建立传输数据的“管道”</li><li>确认提交给浏览器进程</li></ul><h2 id="_10-浏览器-更新页面状态" tabindex="-1">10.浏览器（更新页面状态） <a class="header-anchor" href="#_10-浏览器-更新页面状态" aria-label="Permalink to &quot;10.浏览器（更新页面状态）&quot;">​</a></h2><p>浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页</p><p>此时的 web 页面是空白页，以下列举了三种状态更新</p><ul><li>安全状态</li><li>地址栏的 URL</li><li>前进后退的历史状态</li></ul><h2 id="渲染流程-可以看成步骤-9-的补充" tabindex="-1">渲染流程（可以看成步骤 9 的补充） <a class="header-anchor" href="#渲染流程-可以看成步骤-9-的补充" aria-label="Permalink to &quot;渲染流程（可以看成步骤 9 的补充）&quot;">​</a></h2><p>导航被提交后又会怎么样呢？就进入了渲染阶段。 <br></p><h2 id="主线程" tabindex="-1">主线程 <a class="header-anchor" href="#主线程" aria-label="Permalink to &quot;主线程&quot;">​</a></h2><h2 id="_1-dom-树" tabindex="-1">1.DOM 树 <a class="header-anchor" href="#_1-dom-树" aria-label="Permalink to &quot;1.DOM 树&quot;">​</a></h2><p>HTML 通过 HTML 解析器解析输出 DOM 树。 下面的 HTML 代码会被解析成上面这种浏览器可以理解的 DOM 树结构：</p><p><img src="`+r+'" alt=""></p><h3 id="_2-style-样式计算" tabindex="-1">2.Style 样式计算 <a class="header-anchor" href="#_2-style-样式计算" aria-label="Permalink to &quot;2.Style 样式计算&quot;">​</a></h3><ul><li><p>把 CSS 转换为浏览器能够理解的结构--<strong>styleSheets</strong>。 这里一 CSDN 为例可以看到它最新的 styleSheets，会包含引用的外部 CSS 文件、&lt;/style&gt;标记内的 CSS、以及内嵌的 CSS； <img src="'+i+'" alt=""></p></li><li><p>标准化样式表属性值 将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。 <code>1em</code> 被解析成 <code>1px</code>，<code>red</code> 被解析成了 <code>rgb(255,0,0)</code>等等。</p></li><li><p>计算 DOM 树每个节点的具体样式 最终的样式可以通过控制台 element 的 Computed 查看，关于是怎么计算，涉及继承规则和层叠规则，这里就不细讲了。 <img src="'+s+'" alt=""></p></li></ul><h3 id="_3-layout-布局树" tabindex="-1">3.Layout 布局树 <a class="header-anchor" href="#_3-layout-布局树" aria-label="Permalink to &quot;3.Layout 布局树&quot;">​</a></h3><ul><li>创建布局树：遍历 DOM 树中的所有可见节点，加到布局树中。对<code>display：none</code>的就忽略不加。</li><li>布局计算：计算布局树节点的坐标位置。</li></ul><h3 id="_4-layer-图层绘制列表" tabindex="-1">4.layer 图层绘制列表 <a class="header-anchor" href="#_4-layer-图层绘制列表" aria-label="Permalink to &quot;4.layer 图层绘制列表&quot;">​</a></h3><p>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p><p>进入 Layer 页面，操作按钮从左至右功能依次为：平移、旋转、复位。见图： <img src="'+n+'" alt=""></p><h3 id="_5-pain-图层绘制" tabindex="-1">5.Pain 图层绘制 <a class="header-anchor" href="#_5-pain-图层绘制" aria-label="Permalink to &quot;5.Pain 图层绘制&quot;">​</a></h3><p>可以想象你画画，先画远处再画近处，图层绘制也是这种原理。图层绘制阶段，输出待绘制列表。</p><h2 id="合成线程" tabindex="-1">合成线程 <a class="header-anchor" href="#合成线程" aria-label="Permalink to &quot;合成线程&quot;">​</a></h2><h3 id="_6-栅格化-tiles-图块、raster-光栅化" tabindex="-1">6.栅格化（tiles 图块、raster 光栅化） <a class="header-anchor" href="#_6-栅格化-tiles-图块、raster-光栅化" aria-label="Permalink to &quot;6.栅格化（tiles 图块、raster 光栅化）&quot;">​</a></h3><p>在有些情况下，有的图层很大，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>也是因为这个原因，合成线程会将图层进行分块划分为<strong>图块</strong>然后再<strong>栅格化</strong>，将图块转换为位图，而渲染进程通常不做或者做不来格栅化，需要跨进程，使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><h3 id="_7-display-合成和显示" tabindex="-1">7.Display 合成和显示 <a class="header-anchor" href="#_7-display-合成和显示" aria-label="Permalink to &quot;7.Display 合成和显示&quot;">​</a></h3><p>图块都被光栅化，合成线程就会生成一个绘制图块的命令——“<strong>DrawQuad</strong>”提交给浏览器进程。</p><p>浏览器进程接收 DrawQuad 命令，根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>至此页面就被渲染出来了~~完结撒花 ❀❀❀</p><h2 id="渲染流程总结" tabindex="-1">渲染流程总结 <a class="header-anchor" href="#渲染流程总结" aria-label="Permalink to &quot;渲染流程总结&quot;">​</a></h2><p>渲染页面主要做的事：</p><ul><li>1.将浏览器无法直接理解和使用的 HTML，转换为浏览器能够理解的结构--<strong>DOM 树</strong>。</li><li>2.把 CSS 转换为浏览器能够理解的结构--<strong>styleSheets</strong>，并转换样式表中的属性值，使其标准化，计算出 DOM 树中每个节点的具体样式（根据继承规则和层叠规则）。</li><li>3.确定 DOM 元素的几何位置信息--<strong>布局树</strong>，遍历 DOM 树中的所有可见节点，加入到布局树（display：none 不包含），并计算布局树节点的坐标位置。</li><li>4.如果页面有复杂的效果，如常见的页面滚动，或者使用 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<strong>图层树</strong>（LayerTree）。</li><li>5.图层绘制，把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个<strong>待绘制列表</strong>（联想自己画画）。</li><li>6.tiles：将图层转换成图块。</li><li>7.光栅化：通过进程实现图块转换成位图。</li><li>8.display：浏览器进程拿到 DrawQuad 信息生成页面显示。</li></ul><blockquote><p>DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p></blockquote><p>贴心的我也为你们做了一张图：</p><p><img src="'+d+'" alt="渲染流程"></p>',73),h=[p];function u(_,b,m,g,P,q){return l(),e("div",null,h)}const x=a(c,[["render",u]]);export{T as __pageData,x as default};
